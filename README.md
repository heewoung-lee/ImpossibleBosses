![ChatGPT Image 2025년 5월 21일 오전 07_58_25](https://github.com/user-attachments/assets/78780fee-a54d-4b52-90dc-0bca75f68ba7)
## 📘 목차
- [프로젝트 소개](#프로젝트-소개)
- [개발 기간](#개발-기간)
- [사용 기술](#사용-기술)
- [핵심 로직](#핵심-로직)


<br/>
<br/>

## 🔍 프로젝트 소개
**Impossible Bosses** 는 협동 PvE 보스 레이드에 초점을 둔 멀티플레이 액션 RPG입니다.  
플레이어들은 힘을 합쳐 보스를 쓰러뜨리고, 더 강력한 **무기**와 **능력치**를 획득·강화하여 최종 보스에게 도전합니다.


<br/>
<br/>


## 📆 개발 기간
🗓 **2024-12-11 ~ **


<br/>
<br/>

## 🔧 사용 기술
| 구분 | 스택 |
|:--|:--|
| **Engine** | `Unity 6` |
| **Networking** | `Unity Netcode` |
| **Voice & Chat** | `Vivox Service` |
| **Auth / DB** | `Google OAuth 2`, `Google Spreadsheet` |
| **AI Behavior** | `Behaviour Tree Designer` |
| **TestTool** | `Unity Play Mode Scenarios` |


<br/>
<br/>

## 🗝 핵심 로직

### 🔐 로그인
1. **외부 인증**  
   - 플레이어는 Google OAuth2 로그인 버튼을 누릅니다.  
   - 브라우저 팝업에서 Google 계정으로 인증이 끝나면 **ID 토큰**을 받습니다.
2. **계정 식별 & 데이터베이스 연결**  
   - 토큰 안에 들어있는 구글 고유 사용자 ID를 **스프레드시트**에서 검색합니다.  
   - 첫 방문이면 새 행을 만들고, 기존이면 해당 행 위치를 기억합니다.
3. **세션 준비**  
   - 음성 채팅(Vivox)과 네트워크 서비스(Netcode)가 이 ID를 기반으로 세션을 열어,  
     이후 모든 통신은 “플레이어 ID = 스프레드시트 행” 구조로 매핑됩니다.



### 📥 데이터 불러오기
- 로그인 직후, 스프레드시트에서 **플레이어 정보**(레벨, 인벤토리, 버프 목록 등)를 한 번에 읽어 옵니다.  
- 불러온 데이터는  
  1) ‘버프 캐시’ → 전투 중 빠르게 참조할 수 있도록 메모리에 저장  
  2) ‘아이템 인벤토리’ → UI와 동기화  
  3) ‘스탯’ → 캐릭터 컨트롤러에 바로 적용  
- 이렇게 하면 게임을 다시 켜도 **서버 <-> 로컬** 상태가 항상 일관되게 맞춰집니다.



### 🏠 로비
1. **방 생성 / 입장**  
   - 플레이어가 ‘방 만들기’를 누르면 Unity Lobby 서비스가 고유한 **Join Code**(초대 코드)를 발급합니다.  
   - 친구는 이 코드를 입력해 같은 방에 합류합니다.
2. **실시간 이벤트**  
   - 방 안에서 일어나는 “Ready 버튼 클릭, 채팅, 팀 변경” 이벤트는 로비 서버가 중계합니다.  
   - 각 클라이언트는 이 이벤트를 받아 자신의 UI만 업데이트하므로 네트워크 부하가 적습니다.
3. **호스트 변경(Host Migration)**  
   - 호스트가 나가면 로비 서버가 자동으로 새 호스트를 지정하고,  
     우리 쪽에선 **호스트 교체 이벤트**를 받아 Relay/Netcode 연결을 다시 엽니다.



### 🔗 릴레이 서버
- **호스트(방장)** 가 게임을 시작하면 Relay 서비스가 **트래픽 허브** 역할을 합니다.  
  - 호스트는 “Allocation”을 받아 서버 역할을 하고,  
  - 참가자는 “Join Code”를 사용해 그 Allocation에 붙습니다.  
- 덕분에 플레이어들은 서로의 실제 IP를 몰라도 되고, NAT/방화벽 문제 없이 통신할 수 있습니다.  
- 만약 호스트가 중도 이탈하면, 새 호스트가 Allocation을 다시 받아 연결을 **끊김 없이 승계**합니다.



### 🏎️ 최적화 방법
| 영역 | 왜 이런 방법을 썼는가? |
|------|-----------------------|
| **오브젝트 풀링** | 탄, 파티클, 보스 소환물처럼 “자주 생성·삭제”되는 오브젝트를 미리 만들어 reuse → GC 쓰레기 최소화 |
| **네트워크 패킷 절감** | 프레임당 30 → 20 Tick, 필요 데이터만 압축해 전송 → 모바일에서도 안정적 |
| **렌더링** | 지형은 **Instancing** 활성화, 파티클은 전용 **VFX 매니저**가 수명 주기를 관리 → GPU 부하 완화 |
| **테스트 자동화** | Unity Play Mode Scenarios로 “로그인 → 로비 → 전투 시작” 시나리오를 매 빌드마다 실행해 회귀 버그 방지 |



### 🌐 네트워크 동기화
1. **서버 권한 구조**  
   - 보스 AI와 게임 판정은 **호스트**가 단독으로 계산합니다.  
   - 결과(피해량, 상태 변화)를 **NetworkVariable / RPC**로 모든 클라이언트에 전송합니다.
2. **동기화 단위**  
   - **결정적(Deterministic) 데이터**: 위치, 체력, 애니메이션 타이밍 → 신뢰성 높은 채널로 전송  
   - **연출용 데이터**: 카메라 흔들림, 데미지 숫자 → 가벼운 Unreliable 채널 사용
3. **예측 & 보간**  
   - 플레이어 입력은 먼저 **로컬 예측**으로 즉시 반영, 서버와 차이가 나면 부드럽게 보정합니다.  
   - 원격 플레이어/보스 위치는 **보간**으로 끊김 없이 이어집니다.

---

